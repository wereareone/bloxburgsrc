local http_service = game:GetService("HttpService")
local replicated_storage = game:GetService("ReplicatedStorage")
local workspace = game:GetService("Workspace")
local tween_service = game:GetService("TweenService")
local players = game:GetService("Players")
local player = players.LocalPlayer
local http_request = request
local http = game:GetService("HttpService")
local tp_service = game:GetService("TeleportService")
local pathfinding_service = game:GetService("PathfindingService")
local lighting = game:GetService("Lighting")
local debris = game:GetService("Debris")
local ReplicatedStorage = game:GetService("ReplicatedStorage")


local function num_with_commas(n)
	return tostring(math.floor(n)):reverse():gsub("(%d%d%d)", "%1,"):gsub(",(%-?)$", "%1"):reverse()
end

if not LPH_OBFUSCATED then
	LPH_NO_VIRTUALIZE = function(...)
		return (...)
	end
end

local modules = {
	job_manager = require(player.PlayerScripts.Modules.JobHandler),
	data_manager = require(replicated_storage.Modules.DataService),
	vehicle_manager = require(replicated_storage.Modules.VehicleService),
	player_stats = replicated_storage.Stats[player.Name],
	notification_ui = require(player.PlayerScripts.Modules["_UI"].NotificationUI),
	gui_handler = require(player.PlayerScripts.Modules["_Utilities"].GUIHandler),
	skill_data = require(replicated_storage.Modules["_Data"].SkillData),
	item_data = require(replicated_storage.Modules.ItemService.ItemData)(),
	item_service = require(replicated_storage.Modules.ItemService),
	food_service = require(replicated_storage.Modules.FoodService),
	bill_service = require(replicated_storage.Modules.BillService),
	equip_service = require(replicated_storage.Modules.EquipmentService),
}

local function create_notification(title, description, icon)
	modules.notification_ui:CreateNotification(title, description, icon)
end
local WereIcon = "rbxthumb://type=Asset&id=119978200516532&w=420&h=420"
local service_names = {
	"Players",
	"ReplicatedStorage",
	"Workspace",
	"TweenService",
	"HttpService",
	"RunService",
	"UserInputService",
	"Lighting",
	"TeleportService",
	"MarketplaceService",
}

local services = {}
for _, name in ipairs(service_names) do
	services[name] = game:GetService(name)
end


--// Autobuild Functions
local autobuild_services = {
	material_data = require(replicated_storage.Modules["_Data"].MaterialData),
	fence_service = require(replicated_storage.Modules["_Objects"].FenceService),
	object_service = require(game:GetService("ReplicatedStorage").Modules.ObjectService),
	item_service = require(replicated_storage.Modules.ItemService),
	plot_service = require(replicated_storage.Modules.PlotService),
	resize_service = require(replicated_storage.Modules.ResizeService),
	color_service = require(replicated_storage.Modules.ColorService),
	item_data = require(replicated_storage.Modules.ItemService.ItemData)(),
	wall_service = require(replicated_storage.Modules.WallService),
    enable_build_delay = true,
}

local getRemote = debug.getupvalue(modules.data_manager.FireServer, 5)
function fireServer(args)
	local clonedArgs = table.clone(args)
	local remote = getRemote(clonedArgs.Type)

	if not remote then
		return
	end

	clonedArgs.Type = nil

	return remote:FireServer(clonedArgs)
end

function invokeServer(args)
	local clonedArgs = table.clone(args)
	local remote = getRemote(clonedArgs.Type, true)

	if not remote then
		return
	end

	clonedArgs.Type = nil

	return remote:InvokeServer(clonedArgs)
end

local autobuild_functions = {}
local autobuild_settings = {
	use_vehicles = false,
	use_blockbux = false,
	use_blockbux_amount = 0,
	max_item_amount = 200000,
	player = nil,
	build_id = nil,
	build_delay = 0.3,
}

autobuild_functions.get_plot = function(user)
	return workspace.Plots:FindFirstChild("Plot_" .. user)
end

autobuild_functions.save_house = function(player)
	local targetPlot = autobuild_functions.get_plot(player)

	local saveData = {
		Walls = {},
		Floors = {},
		Roofs = {},
		Fences = {},
		Counters = {},
		Objects = {},
		Basements = {},
		Pools = {},
		Paths = {},
		FrontObjects = {
			Mailbox = {
				CFrame = nil,
				Name = nil,
				Color = nil,
			},
			Trash = {
				CFrame = nil,
				Name = nil,
				Color = nil,
			},
			Position = nil,
		},
		Information = {
			TotalCost = 0,
			TotalItems = 0,
			TotalBlockbux = 0,
			Gamepasses = {},
			Skills = {},
		},
	}
	local floorsSort = {
		id = 1,
		floors = {},
	}

	-- functions
	local encode = {
		position = function(position)
			return { position.X, position.Y, position.Z }
		end,
		cframe = function(cframe)
			return { cframe:components() }
		end,
	}
	local decode = {
		cframe = function(cframe)
			return CFrame.new(unpack(cframe))
		end,
		position = function(position)
			return Vector3.new(unpack(position))
		end,
	}

	local function findFloor(position)
		local raycastParams = RaycastParams.new()
		raycastParams.FilterType = Enum.RaycastFilterType.Whitelist
		raycastParams.FilterDescendantsInstances = { targetPlot }
		raycastParams.IgnoreWater = true
		local floorPart = workspace:Raycast(position, Vector3.new(0, -100, 0), raycastParams)
		local instance
		if floorPart then
			if floorPart.Instance then
				instance = floorPart.Instance
				if (instance.Parent ~= targetPlot.GroundParts) and (instance.Parent ~= targetPlot) then
					if instance.Parent then
						while instance.Parent.Parent ~= targetPlot.House do
							instance = instance.Parent
						end
					else
						return targetPlot.PrimaryPart
					end
				end
			else
				return targetPlot.PrimaryPart
			end
		else
			return targetPlot.PrimaryPart
		end
		return instance
	end
	local function getFloorId(floor)
		local currentId = floorsSort.id
		floorsSort.id = floorsSort.id + 1

		table.insert(floorsSort.floors, {
			floor = floor,
			id = floorsSort.id,
		})
		return currentId
	end

	local function savePosition(position)
		local position = autobuild_services.object_service:RoundToSaveResolution(CFrame.new(position)).Position
		return encode.position(targetPlot.Water.CFrame:PointToObjectSpace(position))
	end
	local function saveCFrame(cframe)
		local cframe = autobuild_services.object_service:RoundToSaveResolution(cframe)
		return encode.cframe(targetPlot.Water.CFrame:ToObjectSpace(cframe))
	end

	local function saveColor(object)
		local name = {}
		local number = autobuild_services.color_service:GetAppearanceData(object)

		for index, inner in next, number do
			if #inner == 0 then
				name[index] = {}
			else
				local insert = {}

				local colorId = tonumber(inner[1])
				if colorId then
					insert[1] = colorId
					saveData.Information.TotalCost += 5

					if object.Name ~= "Poster" and colorId < 0 then
						if not table.find(saveData.Information.Gamepasses, "Custom Colors") then
							table.insert(saveData.Information.Gamepasses, "Custom Colors")
						end
					end
				else
					insert[1] = "0"
				end

				local materialId = tonumber(inner[2])
				if materialId and materialId ~= 0 then
					insert[2] = autobuild_services.material_data:GetMaterialFromID(materialId).Name
					saveData.Information.TotalCost += 20
				else
					insert[2] = 0
				end

				name[index] = insert
			end
		end

		return name
	end

	local function canBeResized(itemName)
		return autobuild_services.resize_service.CanResize(
			"",
			client,
			autobuild_services.item_service:GetItem(itemName)
		)
	end
	local function getResizeData(item)
		local resizeData = item:GetAttribute("_resizeRootSize1")
		if not resizeData then
			return
		end
		return encode.position(resizeData)
	end

	local function roundVector3(vector3)
		local tempResult = { floorNumber(vector3.X, 1), floorNumber(vector3.Y, 1), floorNumber(vector3.Z, 1) }
		return tempResult
	end
	local function updateCost(itemName)
		saveData.Information.TotalItems = saveData.Information.TotalItems + 1

		local item = autobuild_services.item_service:GetItem(itemName)

		if item then
			if item.Price and item.Price > 0 then
				saveData.Information.TotalCost = saveData.Information.TotalCost + item.Price
			elseif item.BSPrice and item.BSPrice > 0 then
				saveData.Information.TotalBlockbux = saveData.Information.TotalBlockbux + item.BSPrice
			end
		else
			saveData.Information.TotalCost = saveData.Information.TotalCost
				+ autobuild_services.plot_service:GetObjectValue(itemName)
		end
	end

	local function saveInnerObjects(holder, skipSideValue)
		if not holder then
			return
		end
		if not holder:FindFirstChild("ItemHolder") or holder.ItemHolder:GetChildren() == 0 then
			return
		end

		local Objects = {}
		for _, object in pairs(holder.ItemHolder:GetChildren()) do
			if not object:IsA("BasePart") then
				continue
			end
			updateCost(object)

			local objectArray = {}
			local sideValue
			do
				if object:FindFirstChild("SideValue") then
					sideValue = object.SideValue.Value
				else
					sideValue = nil
				end
				if skipSideValue == true then
					sideValue = nil
				end
			end
			if object:GetAttribute("_transformStart") then
				if not table.find(saveData.Information.Gamepasses, "Transform Plus") then
					table.insert(saveData.Information.Gamepasses, "Transform Plus")
				end

				local offset
				if object.Parent.Parent.Name == "Wall" then
					offset = object.Parent.Parent.SizeBox.CFrame:ToObjectSpace(object.CFrame)
				else
					offset = targetPlot.Ground.CFrame:ToObjectSpace(object.CFrame)
				end

				objectArray.CFrame = saveCFrame(object.CFrame)
				objectArray.TransformData = encode.cframe(offset)
			else
				objectArray.CFrame = saveCFrame(object.CFrame)
			end

			if
				object
				and object:FindFirstChild("ObjectModel")
				and object.ObjectModel:FindFirstChild("StartPart")
				and object.ObjectModel:FindFirstChild("EndPart")
			then
				objectArray.StartPart = savePosition(object.ObjectModel.StartPart.Position)
				objectArray.EndPart = savePosition(object.ObjectModel.EndPart.Position)
			end

			objectArray.Name = object.Name
			objectArray.Side = sideValue
			objectArray.Color = saveColor(object)

			if object:FindFirstChild("ObjectData") and object.ObjectData:FindFirstChild("Height") then
				objectArray.Height = object.ObjectData:FindFirstChild("Height").Value
			end

			do
				if object:FindFirstChild("ObjectData") then
					if object.ObjectData:FindFirstChild("Image") then
						objectArray.Image = object.ObjectData:FindFirstChild("Image").Value
					end
				end
			end
			do
				if object:GetAttribute("_resizeRootSize1") ~= nil then
					objectArray.ResizeData = encode.position(object:GetAttribute("_resizeRootSize1"))
				end
			end

			objectArray.Objects = saveInnerObjects(object, true)

			table.insert(Objects, objectArray)
		end

		return Objects
	end

	-- save objects
	do
		for _, wall in next, targetPlot.House.Walls:GetChildren() do
			if wall.Name == "Poles" then
				continue
			end
			updateCost(wall)

			local insertValue = {}

			local wallTo, wallFrom = autobuild_services.wall_service:GetWallEdges(wall)

			insertValue.Position = {
				From = savePosition(wallFrom),
				To = savePosition(wallTo),
			}

			insertValue.Color = {
				Right = saveColor(wall.RPart)[1],
				Left = saveColor(wall.RPart)[2],
			}

			insertValue.Objects = saveInnerObjects(wall)
			if not saveData.Objects then
				saveData.Objects = {}
			end
			table.insert(saveData.Walls, insertValue)
		end
		for _, floor in next, targetPlot.House.Floor:GetChildren() do
			updateCost(floor)

			local insertValue = {}

			insertValue.Id = getFloorId(floor)
			insertValue.Color = saveColor(floor)
			insertValue.Points = {}
			do
				for _, point in next, floor.PointData:GetChildren() do
					table.insert(
						insertValue.Points,
						savePosition(targetPlot.Ground.CFrame:PointToWorldSpace(point.Value) + Vector3.new(0, 0.05, 0))
					)
				end
			end

			table.insert(saveData.Floors, insertValue)
		end
		for _, roof in next, targetPlot.House.Roof:GetChildren() do
			updateCost(roof)

			local inputValue = {}
			inputValue.Points = {}
			inputValue.Settings = {
				Type = roof.Name,
				IsPreview = true,
			}
			inputValue.Color = saveColor(roof)

			for _, point in next, roof.PointData:GetChildren() do
				table.insert(
					inputValue.Points,
					savePosition(targetPlot.Ground.CFrame:PointToWorldSpace(point.Value) + Vector3.new(0, 0.05, 0))
				)
			end
			for _, setting in next, roof.PropertyData:GetChildren() do
				inputValue.Settings[setting.Name] = setting.Value
			end

			inputValue.Objects = saveInnerObjects(roof)
			table.insert(saveData.Roofs, inputValue)
		end

		for _, fence in next, targetPlot.House.Fences:GetChildren() do
			if fence.Name == "Poles" then
				continue
			end
			updateCost(fence)

			local from, to = autobuild_services.fence_service:GetEdgePositions(fence)

			local inputValue = {}
			inputValue.From = savePosition(from)
			inputValue.To = savePosition(to)
			inputValue.Name = fence.Name
			inputValue.Color = saveColor(fence)

			inputValue.Objects = saveInnerObjects(fence)

			table.insert(saveData.Fences, inputValue)
		end
		for _, counter in next, targetPlot.House.Counters:GetChildren() do
			local success = pcall(function()
				updateCost(counter)

				local inputValue = {
					Name = counter.Name,
					CFrame = saveCFrame(counter.CFrame),
					Color = saveColor(counter),
				}

				do
					local floorUsed = findFloor(counter.Position)
					for _, array in next, floorsSort.floors do
						if array.floor == floorUsed then
							inputValue.Id = array.id
							break
						end
					end
					inputValue.Id = inputValue.Id or 0
				end

				local okInner, inner = pcall(function()
					return saveInnerObjects(counter)
				end)

				if okInner and inner then
					for _, obj in ipairs(inner) do
						local ok = pcall(function()
							http_service:JSONEncode(obj)
						end)
						if ok then
							table.insert(saveData.Objects, obj)
						end
					end
				end

				table.insert(saveData.Counters, inputValue)
			end)
		end

		for _, basement in next, targetPlot.House.Basements:GetChildren() do
			updateCost(basement)

			local basementData = {}
			basementDataName = basement.Name
			basementData.Center = saveCFrame(basement.PrimaryPart.CFrame)
			basementData.Size = { basement.PrimaryPart.Size.X, basement.PrimaryPart.Size.Z }

			table.insert(saveData.Basements, basementData)
		end
		for _, pool in next, targetPlot.House.Pools:GetChildren() do
			updateCost(pool)

			local poolData = {}
			poolData.Name = pool.Name
			poolData.Center = saveCFrame(pool.PrimaryPart.CFrame)
			poolData.Size = { pool.PrimaryPart.Size.X, pool.PrimaryPart.Size.Z }
			poolData.Color = saveColor(pool)

			table.insert(saveData.Pools, poolData)
		end
		for _, path in next, targetPlot.House.Paths:GetChildren() do
			if path.Name == "Poles" then
				continue
			end

            updateCost(path)

			local pathData = {}
			pathData.Name = path.Name
			pathData.Color = saveColor(path)
			pathData.To = savePosition(path.BPole.Value.Parent.Position)
			pathData.From = savePosition(path.FPole.Value.Parent.Position)

			pathData.Objects = saveInnerObjects(path)
			table.insert(saveData.Paths, pathData)
		end
		for _, object in next, targetPlot.House.Objects:GetChildren() do
			updateCost(object)

			local inputValue = {}
			inputValue["Name"] = object.Name
			inputValue["Color"] = saveColor(object)

			if object:GetAttribute("_transformStart") then
				if not table.find(saveData.Information.Gamepasses, "Transform Plus") then
					table.insert(saveData.Information.Gamepasses, "Transform Plus")
				end

				local offset = targetPlot.Ground.CFrame:ToObjectSpace(object.CFrame)

				inputValue["CFrame"] = saveCFrame(object.CFrame)
				inputValue["TransformData"] = encode.cframe(offset)
			else
				inputValue["CFrame"] = saveCFrame(object.CFrame)
			end

			if object:FindFirstChild("ObjectData") and object.ObjectData:FindFirstChild("Height") then
				inputValue["Height"] = object.ObjectData:FindFirstChild("Height").Value
			end

			if object:FindFirstChild("ObjectData") and object.ObjectData:FindFirstChild("Image") then
				inputValue["Image"] = object.ObjectData:FindFirstChild("Image").Value
			end
			do
				local floorUsed = findFloor(object.Position)
				for _, array in next, floorsSort.floors do
					if array.floor == floorUsed then
						inputValue.Id = array.id
						break
					end
				end

				inputValue.Id = inputValue.Id or 0
			end
			do
				if canBeResized(object.Name) then
					inputValue.ResizeData = getResizeData(object)
				end
			end
			if not saveData.Objects then
				saveData.Objects = {}
			end
			inputValue.Objects = saveInnerObjects(object)
			table.insert(saveData.Objects, inputValue)
		end
	end

	local function deepClone(tab)
		local endTable = {}

		for index, value in pairs(tab) do
			if type(value) == "table" then
				endTable[index] = deepClone(value)
			else
				endTable[index] = value
			end
		end

		return endTable
	end

	local deepsaveData = deepClone(saveData)

	do
		local function GetPos(tab)
			if type(tab) ~= "table" then
				return false
			end

			if tab["To"] and tab["From"] and #tab["To"] == 3 and #tab["From"] == 3 then
				return decode.position(tab["To"])
			end

			if tab["Position"] and type(tab["Position"]) == "table" and #tab["Position"] == 3 then
				return decode.position(tab["Position"])
			end

			if tab["CFrame"] and type(tab["CFrame"]) == "table" then
				if #tab["CFrame"] == 3 then
					return decode.position(tab["CFrame"])
				elseif #tab["CFrame"] > 3 then
					return decode.cframe(tab["CFrame"])
				end
			end

			return false
		end

		for _, value in pairs(deepsaveData) do
			if type(value) == "table" then
				for _, innerValue in pairs(value) do
					if type(innerValue) == "table" then
						for _, innerInnerValue in pairs(innerValue) do
							if type(innerInnerValue) == "table" then
								local position = GetPos(innerInnerValue)
								if not position then
								else
									if
										table.find(saveData.Information.Gamepasses, "Large Plot")
										and table.find(saveData.Information.Gamepasses, "Multiple Floors")
									then
										break
									end

									if
										(position.X <= -75 or position.X >= 75 or position.Z >= 25)
										and not table.find(saveData.Information.Gamepasses, "Large Plot")
									then
										table.insert(saveData.Information.Gamepasses, "Large Plot")
									end
									if
										position.Y >= 15.85
										and not table.find(saveData.Information.Gamepasses, "Multiple Floors")
									then
										table.insert(saveData.Information.Gamepasses, "Multiple Floors")
									end
								end
							end
						end
					end
				end
			end
		end
	end

	if #saveData.Basements > 0 then
		table.insert(saveData.Information.Gamepasses, "Basements")
	end
	for _, object in pairs(saveData.Objects) do
		if object.ResizeData then
			if not table.find(saveData.Information.Gamepasses, "Advanced Placement") then
				table.insert(saveData.Information.Gamepasses, "Advanced Placement")
			end
			break
		end
		if object.Objects then
			for _, inner in pairs(object.Objects) do
				if inner.ResizeData and not table.find(saveData.Information.Gamepasses, "Advanced Placement") then
					table.insert(saveData.Information.Gamepasses, "Advanced Placement")
					break
				end
			end
		end
	end

	for _, object in pairs(saveData.Objects) do
		if object.TransformData then
			table.insert(saveData.Information.Gamepasses, "Transform Plus")
			break
		end
		if object.Objects then
			for _, inner in pairs(object.Objects) do
				if inner.TransformData and not table.find(saveData.Information.Gamepasses, "Transform Plus") then
					table.insert(saveData.Information.Gamepasses, "Transform Plus")
					break
				end
			end
		end
	end

	do
		local skillLevels = {}

		for _, obj in ipairs(saveData.Objects or {}) do
			local name = obj.Name
			if typeof(name) ~= "string" then
				continue
			end

			local item = autobuild_services.item_service:GetItem(name)
			if not item then
				continue
			end

			local requirements = item.Locked or {}
			for req, level in pairs(requirements) do
				if typeof(req) == "string" and req == "Skill_Gardening" and typeof(level) == "number" then
					if not skillLevels["Gardening"] or level > skillLevels["Gardening"] then
						skillLevels["Gardening"] = level
					end
				end
			end
		end

		saveData.Information.Skills = saveData.Information.Skills or {}

		if #saveData.Information.Skills == 0 then
			for skillName, level in pairs(skillLevels) do
				local skillStr = string.format("%s %d", skillName, level)
				table.insert(saveData.Information.Skills, skillStr)
			end
		end
	end

	-- Transform data to match server expected format
	local final = {
		player_name = player,
		walls = {},
		floors = {},
		paths = {},
		pools = {},
		roofs = {},
		objects = {},
		fences = {},
		counters = {},
		basements = {},
		gamepasses = saveData.Information.Gamepasses,
		skills = saveData.Information.Skills,
		real_value = saveData.Information.TotalCost,
		blockbux_value = saveData.Information.TotalBlockbux,
	}

	-- Convert walls data
	for _, wall in pairs(saveData.Walls) do
		table.insert(final.walls, {
			From = wall.Position.From,
			To = wall.Position.To,
			Objects = wall.Objects or {},
			LeftColor = {
				ColorNumber = wall.Color.Left[1] or 194,
				MaterialNumber = wall.Color.Left[2] or 15,
			},
			RightColor = {
				ColorNumber = wall.Color.Right[1] or 194,
				MaterialNumber = wall.Color.Right[2] or 15,
			},
		})
	end

	-- Convert floors data
	for _, floor in pairs(saveData.Floors) do
		table.insert(final.floors, {
			Points = floor.Points,
			Color = floor.Color,
		})
	end

	-- Convert roofs data
    for _, roof in pairs(saveData.Roofs) do
		table.insert(final.roofs, {
			Points = roof.Points,
			Height = roof.Settings.Height or 0,
			Type = roof.Settings.Type,
			Color = roof.Color,
		})
	end

	-- Convert fences data
	for _, fence in pairs(saveData.Fences) do
		table.insert(final.fences, {
			Name = fence.Name,
			From = fence.From,
			To = fence.To,
			Color = fence.Color,
			Objects = fence.Objects or {},
		})
	end

	-- Convert paths data
	for _, path in pairs(saveData.Paths) do
		table.insert(final.paths, {
			From = path.From,
			To = path.To,
			Color = path.Color,
		})
	end

	-- Convert counters data
	for _, counter in pairs(saveData.Counters) do
		table.insert(final.counters, {
			Name = counter.Name,
			CFrame = counter.CFrame,
			Color = counter.Color,
			id = counter.Id,
		})
	end

	-- Convert basements data
	for _, basement in pairs(saveData.Basements) do
		table.insert(final.basements, {
			Center = basement.Center,
			Size = basement.Size,
		})
	end

	-- Convert pools data
	for _, pool in pairs(saveData.Pools) do
		table.insert(final.pools, {
			Name = pool.Name,
			Center = pool.Center,
			Size = pool.Size,
			Color = pool.Color,
			Objects = pool.Objects or {},
		})
	end

	-- Convert objects data
	for _, object in pairs(saveData.Objects) do
		table.insert(final.objects, {
			Name = object.Name,
			Position = object.Position,
			CFrame = object.CFrame,
			Offset = object.TransformData,
			Color = object.Color,
			Size = object.ResizeData,
			Height = object.Height,
			Image = object.Image,
			Objects = object.Objects,
		})
	end

	local jsonData = http_service:JSONEncode(final)
	print("JSON Length:", #jsonData)

	-- Upload the data to server
	local upload_response = request({
		Url = "https://weretools.ddns.net/api/upload",
		Method = "POST",
		Headers = { ["Content-Type"] = "application/json" },
		Body = jsonData,
	})
	print("Upload Status Code:", upload_response.StatusCode)

	if upload_response.StatusCode ~= 200 then
		create_notification("Upload Failed", WereIcon ,"Failed to upload data | Rate Limit")
		return nil
	end

	local upload_result = http_service:JSONDecode(upload_response.Body)
	local id = upload_result.id
	print("Upload Result ID:", id)

	if not id then
		create_notification("Error", WereIcon ,"Failed to get ID from API")
		return nil
	end

	-- Get build information from server
	local get_response = http_service:JSONDecode(request({
		Url = "https://weretools.ddns.net/api/upload/" .. id,
		Method = "GET",
	}).Body)

	get_response = get_response.data
	print("Get Response Real Value:", get_response.real_value, "Blockbux Value:", get_response.blockbux_value)

	-- Get required gamepasses
	local gamepasses = http_service:JSONDecode(request({
		Url = "https://weretools.ddns.net/api/gamepasses?id=" .. id,
		Method = "GET",
	}).Body)
	
	local requiredRaw = ""
	if gamepasses and gamepasses.required_gamepass then
		requiredRaw = gamepasses.required_gamepass
	elseif gamepasses and gamepasses.data and gamepasses.data.required_gamepass then
		requiredRaw = gamepasses.data.required_gamepass
	end
	
	local requiredList = requiredRaw:gsub("\n", ", "):gsub("%s+$", "")
	if requiredList == "" then
		requiredList = "None"
	end
	
	local cleanId = id:gsub("[%s\n\r]+", "")

	-- Show success notification
	create_notification(
		"Build Saved Successfully! 🎉",
        WereIcon,
		"💰 Cost: " .. num_with_commas(get_response.real_value) .. 
		"\n💎 Blockbux: " .. num_with_commas(get_response.blockbux_value) .. 
		"\n🎮 Gamepasses: " .. requiredList .. 
		"\n🆔 ID: " .. cleanId
	)

	-- Copy ID to clipboard
	if setclipboard then
		setclipboard(cleanId)
	end
	print("=== SAVE COMPLETE ===")
	print("Build ID:", cleanId)
	print("Total Cost:", num_with_commas(get_response.real_value))
	print("Blockbux Cost:", num_with_commas(get_response.blockbux_value))
	print("Required Gamepasses:", requiredList)
	
	return {
		id = cleanId,
		cost = get_response.real_value,
		blockbux = get_response.blockbux_value,
		gamepasses = requiredList
	}
end

local paused = nil

function autobuild_functions.is_paused()
    return paused
end

function autobuild_functions.set_paused(value)
    paused = value
end

local function save_build_progress(placed, total, styled, total_styling)
    local progress = {
        placed = placed or 0,
        total = total or 0,
        styled = styled or 0,
        total_styling = total_styling or 0
    }
    local json = http_service:JSONEncode(progress)
    pcall(function()
        writefile("build_progress.json", json)
    end)
end

local function load_build_progress()
    local success, data = pcall(function()
        return http_service:JSONDecode(readfile("build_progress.json"))
    end)
    if success and data then
        return data.placed or 0, data.total or 0, data.styled or 0, data.total_styling or 0
    end
    return 0, 0, 0, 0
end

local function load_build_data()
    local success, data = pcall(function()
        return http_service:JSONDecode(readfile("build_data.json"))
    end)
    if success and data then
        return data
    end
    return nil
end

autobuild_functions.load_house = function(building_id, resume_mode)
    -- If not resuming, clear previous progress/data files
    if not resume_mode then
        pcall(function()
            if isfile("build_progress.json") then delfile("build_progress.json") end
            if isfile("build_data.json") then delfile("build_data.json") end
        end)
    end
   -- Declare all variables at the start
    local loadData = nil
    local currentItem = 0
    local stylingCount = 0
    local estimatedStylingTasks = 0
    local totalItems = 0
    local floors = {}
    local toDo = {}
    local retry = {}
    
    -- Check if we should resume from saved progress
   if resume_mode then
        local savedPlaced, savedTotal, savedStyled, savedTotalStyling = load_build_progress()
        local savedData = load_build_data()
        
        if not savedData then
            create_notification("Error", WereIcon, "No saved build data found")
            return
        end
        
        if savedPlaced >= savedTotal then
            create_notification("Info", WereIcon, "Build already completed")
            return
        end

        create_notification("Resume Build", WereIcon, string.format("Continuing from item %d/%d", savedPlaced, savedTotal))

        -- Use saved data instead of fetching from API
        loadData = savedData
        currentItem = savedPlaced -- Start from saved progress
        stylingCount = savedStyled
        estimatedStylingTasks = savedTotalStyling
        totalItems = savedTotal -- FIXED: Use saved total instead of recalculating
    else 
        -- Original fetch logic for new builds
        if not building_id then
            create_notification("Error", WereIcon,"No building ID provided")
            return
        end

        -- Fetch data from server API
        do
            local success, response = pcall(function()
                return http_service:JSONDecode(request({
                    Url = "https://weretools.ddns.net/api/upload/" .. building_id,
                    Method = "GET",
                }).Body)
            end)
            
            if not success then
                create_notification("API Error", WereIcon, "Failed to fetch build data from server")
                return
            end
            
            loadData = response.data
            if not loadData then
                create_notification("Data Error", WereIcon, "Invalid build data received from server")
                return
            end
        end

        pcall(function()
            writefile("build_data.json", http_service:JSONEncode(loadData))
        end)
        
        currentItem = 0 -- Start from beginning for new builds
        stylingCount = 0
    
    end

    -- Get target plot with better validation
    local plotName = tostring(game.ReplicatedStorage.Stats[player.Name].IsBuilding.Value)
    local targetPlot = workspace.Plots:FindFirstChild(plotName)
    
    if not targetPlot then
        create_notification("Error", WereIcon, "Plot not found: " .. plotName)
        return
    end

    -- Validate plot has required components
    if not targetPlot:FindFirstChild("Water") then
        create_notification("Error", WereIcon, "Plot missing Water component")
        return
    end

    if not targetPlot:FindFirstChild("Ground") and not (targetPlot:FindFirstChild("GroundParts") and targetPlot.GroundParts:FindFirstChild("Ground")) then
        create_notification("Error", WereIcon, "Plot missing Ground component")
        return
    end
    
    pcall(function()
        writefile("build_data.json", http_service:JSONEncode(loadData))
    end)
    -- delete old ui
    if player.PlayerGui:FindFirstChild("AutobuildProgress") then
        player.PlayerGui:FindFirstChild("AutobuildProgress"):Destroy()
    end
    -- Modern Progress Bar Setup
    local progressGui = Instance.new("ScreenGui")
    progressGui.Name = "AutobuildProgress"
    progressGui.ResetOnSpawn = false
    progressGui.Parent = player.PlayerGui

    -- Main Container (smaller and at top)
    local container = Instance.new("Frame")
    container.Size = UDim2.new(0, 400, 0, 75)
    container.Position = UDim2.new(0.5, -200, 0, 20)
    container.BackgroundColor3 = Color3.fromRGB(15, 15, 20)
    container.BackgroundTransparency = 0.05
    container.BorderSizePixel = 0
    container.Parent = progressGui

    -- Modern rounded corners
    local containerCorner = Instance.new("UICorner")
    containerCorner.CornerRadius = UDim.new(0, 16)
    containerCorner.Parent = container

    -- Subtle drop shadow
    local shadow = Instance.new("Frame")
    shadow.Size = UDim2.new(1, 4, 1, 4)
    shadow.Position = UDim2.new(0, -2, 0, 2)
    shadow.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    shadow.BackgroundTransparency = 0.8
    shadow.BorderSizePixel = 0
    shadow.ZIndex = -1
    shadow.Parent = container

    local shadowCorner = Instance.new("UICorner")
    shadowCorner.CornerRadius = UDim.new(0, 16)
    shadowCorner.Parent = shadow

    -- Title and status (combined)
    local titleText = Instance.new("TextLabel")
    titleText.Size = UDim2.new(1, -20, 0, 20)
    titleText.Position = UDim2.new(0, 10, 0, 8)
    titleText.BackgroundTransparency = 1
    titleText.Text = "Loading Build"
    titleText.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleText.TextSize = 14
    titleText.Font = Enum.Font.GothamBold
    titleText.TextXAlignment = Enum.TextXAlignment.Left
    titleText.Parent = container

    -- Progress percentage (right aligned)
    local percentText = Instance.new("TextLabel")
    percentText.Size = UDim2.new(0, 80, 0, 20)
    percentText.Position = UDim2.new(1, -90, 0, 8)
    percentText.BackgroundTransparency = 1
    percentText.Text = "0%"
    percentText.TextColor3 = Color3.fromRGB(120, 255, 120)
    percentText.TextSize = 14
    percentText.Font = Enum.Font.GothamBold
    percentText.TextXAlignment = Enum.TextXAlignment.Right
    percentText.Parent = container

    -- Progress bar background
    local progressBg = Instance.new("Frame")
    progressBg.Size = UDim2.new(1, -20, 0, 6)
    progressBg.Position = UDim2.new(0, 10, 0, 33)
    progressBg.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
    progressBg.BorderSizePixel = 0
    progressBg.Parent = container

    local progressBgCorner = Instance.new("UICorner")
    progressBgCorner.CornerRadius = UDim.new(0, 3)
    progressBgCorner.Parent = progressBg

    -- Progress bar fill
    local progressFill = Instance.new("Frame")
    progressFill.Size = UDim2.new(0, 0, 1, 0)
    progressFill.Position = UDim2.new(0, 0, 0, 0)
    progressFill.BackgroundColor3 = Color3.fromRGB(0, 255, 150)
    progressFill.BorderSizePixel = 0
    progressFill.Parent = progressBg

    local progressFillCorner = Instance.new("UICorner")
    progressFillCorner.CornerRadius = UDim.new(0, 3)
    progressFillCorner.Parent = progressFill

    -- Animated gradient
    local gradient = Instance.new("UIGradient")
    gradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 255, 150)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 200, 255))
    }
    gradient.Rotation = 0
    gradient.Parent = progressFill

    -- Subtle moving sheen animation across the progress bar
    local stopProgressAnim
    do
        local running = true
        stopProgressAnim = function()
            running = false
        end
        gradient.Offset = Vector2.new(-1, 0)
        task.spawn(function()
            while running and progressFill and progressFill.Parent do
                local tween1 = tween_service:Create(gradient, TweenInfo.new(1.2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {
                    Offset = Vector2.new(1, 0)
                })
                tween1:Play()
                tween1.Completed:Wait()
                gradient.Offset = Vector2.new(-1, 0)
            end
        end)
    end

    -- Comet at the leading edge (boost-like slider)
    local stopCometAnim
    local comet
    do
        comet = Instance.new("Frame")
        comet.Name = "Comet"
        comet.AnchorPoint = Vector2.new(1, 0.5)
        comet.Position = UDim2.new(1, 0, 0.5, 0)
        comet.Size = UDim2.new(0, 10, 0, 10)
        comet.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        comet.BackgroundTransparency = 0.2
        comet.BorderSizePixel = 0
        comet.ZIndex = progressFill.ZIndex + 2
        comet.Parent = progressFill

        local cometCorner = Instance.new("UICorner")
        cometCorner.CornerRadius = UDim.new(1, 0)
        cometCorner.Parent = comet

        local cometGlow = Instance.new("UIGradient")
        cometGlow.Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0, Color3.fromRGB(255,255,255)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(180,255,230))
        }
        cometGlow.Transparency = NumberSequence.new{
            NumberSequenceKeypoint.new(0, 0.1),
            NumberSequenceKeypoint.new(1, 0.5)
        }
        cometGlow.Parent = comet

        local running = true
        stopCometAnim = function()
            running = false
        end

        task.spawn(function()
            while running and comet.Parent do
                local grow = tween_service:Create(comet, TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {
                    Size = UDim2.new(0, 18, 0, 18),
                    BackgroundTransparency = 0.1
                })
                grow:Play(); grow.Completed:Wait()
                local shrink = tween_service:Create(comet, TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {
                    Size = UDim2.new(0, 10, 0, 10),
                    BackgroundTransparency = 0.3
                })
                shrink:Play(); shrink.Completed:Wait()
            end
        end)
    end

    -- Boost trail/exhaust behind the rocket head
    local boostTrail = Instance.new("Frame")
    boostTrail.Name = "BoostTrail"
    boostTrail.AnchorPoint = Vector2.new(1, 0.5)
    boostTrail.Position = UDim2.new(1, 0, 0.5, 0)
    boostTrail.Size = UDim2.new(0, 60, 0.6, 0) -- default trail length/height
    boostTrail.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    boostTrail.BackgroundTransparency = 0.4
    boostTrail.BorderSizePixel = 0
    boostTrail.ZIndex = progressFill.ZIndex + 1
    boostTrail.Parent = progressFill

    local boostCorner = Instance.new("UICorner")
    boostCorner.CornerRadius = UDim.new(0, 3)
    boostCorner.Parent = boostTrail

    local boostGrad = Instance.new("UIGradient")
    boostGrad.Rotation = 0
    boostGrad.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0.00, Color3.fromRGB(180, 255, 230)),
        ColorSequenceKeypoint.new(0.60, Color3.fromRGB(255, 255, 255)),
        ColorSequenceKeypoint.new(1.00, Color3.fromRGB(255, 255, 255))
    }
    boostGrad.Transparency = NumberSequence.new{
        NumberSequenceKeypoint.new(0.00, 1.0),  -- far left almost invisible
        NumberSequenceKeypoint.new(0.20, 0.6),
        NumberSequenceKeypoint.new(0.60, 0.15), -- near head bright
        NumberSequenceKeypoint.new(1.00, 0.5)
    }
    boostGrad.Parent = boostTrail

    -- Flames attached to the rocket head (comet)
    local stopFlameAnim
    do
        local flameCore = Instance.new("Frame")
        flameCore.Name = "FlameCore"
        flameCore.AnchorPoint = Vector2.new(1, 0.5)
        flameCore.Position = UDim2.new(0, -8, 0.5, 0) -- relative to comet center
        flameCore.Size = UDim2.new(0, 12, 0, 12)
        flameCore.BackgroundColor3 = Color3.fromRGB(255, 210, 80)
        flameCore.BorderSizePixel = 0
        flameCore.BackgroundTransparency = 0.1

        local coreCorner = Instance.new("UICorner")
        coreCorner.CornerRadius = UDim.new(1, 0)
        coreCorner.Parent = flameCore

        local flameGlow = Instance.new("Frame")
        flameGlow.Name = "FlameGlow"
        flameGlow.AnchorPoint = Vector2.new(1, 0.5)
        flameGlow.Position = UDim2.new(0, -12, 0.5, 0)
        flameGlow.Size = UDim2.new(0, 20, 0, 20)
        flameGlow.BackgroundColor3 = Color3.fromRGB(255, 140, 30)
        flameGlow.BorderSizePixel = 0
        flameGlow.BackgroundTransparency = 0.35

        local glowCorner = Instance.new("UICorner")
        glowCorner.CornerRadius = UDim.new(1, 0)
        glowCorner.Parent = flameGlow

        -- Parent flames to the comet so they move with the head
        flameCore.Parent = comet
        flameGlow.Parent = comet

        local running = true
        stopFlameAnim = function()
            running = false
        end

        task.spawn(function()
            while running and comet.Parent do
                local flickerUp = tween_service:Create(flameCore, TweenInfo.new(0.12, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {
                    Size = UDim2.new(0, 14, 0, 14),
                    BackgroundTransparency = 0.0
                })
                local glowUp = tween_service:Create(flameGlow, TweenInfo.new(0.12, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {
                    Size = UDim2.new(0, 26, 0, 26),
                    BackgroundTransparency = 0.2
                })
                flickerUp:Play(); glowUp:Play()
                flickerUp.Completed:Wait()

                local flickerDown = tween_service:Create(flameCore, TweenInfo.new(0.14, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {
                    Size = UDim2.new(0, 12, 0, 12),
                    BackgroundTransparency = 0.15
                })
                local glowDown = tween_service:Create(flameGlow, TweenInfo.new(0.14, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {
                    Size = UDim2.new(0, 20, 0, 20),
                    BackgroundTransparency = 0.4
                })
                glowDown:Play(); flickerDown:Play()
                glowDown.Completed:Wait()
            end
        end)
    end

    -- Smooth boost sweep from start (left) to current percentage
    local boostSweep = Instance.new("Frame")
    boostSweep.Name = "BoostSweep"
    boostSweep.AnchorPoint = Vector2.new(0, 0.5)
    boostSweep.Position = UDim2.new(0, 0, 0.5, 0)
    boostSweep.Size = UDim2.new(0, 0, 1, 0)
    boostSweep.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    boostSweep.BackgroundTransparency = 1
    boostSweep.BorderSizePixel = 0
    boostSweep.ZIndex = progressFill.ZIndex + 1
    boostSweep.Visible = false
    boostSweep.Parent = progressFill

    local boostSweepCorner = Instance.new("UICorner")
    boostSweepCorner.CornerRadius = UDim.new(0, 3)
    boostSweepCorner.Parent = boostSweep

    local boostSweepGrad = Instance.new("UIGradient")
    boostSweepGrad.Rotation = 0
    boostSweepGrad.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(200,255,235)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(255,255,255))
    }
    boostSweepGrad.Transparency = NumberSequence.new{
        NumberSequenceKeypoint.new(0, 0.0),
        NumberSequenceKeypoint.new(1, 0.5)
    }
    boostSweepGrad.Parent = boostSweep

    local boostSweepTween
    local function triggerBoostSweep(targetPercent)
        if not boostSweep or not boostSweep.Parent then return end
        if targetPercent <= 0 then return end
        if boostSweepTween and boostSweepTween.PlaybackState == Enum.PlaybackState.Playing then
            boostSweepTween:Cancel()
        end
        boostSweep.Visible = true
        boostSweep.BackgroundTransparency = 0.2
        boostSweep.Size = UDim2.new(0, 0, 1, 0)
        boostSweepTween = tween_service:Create(boostSweep, TweenInfo.new(0.35, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
            Size = UDim2.new(targetPercent, 0, 1, 0),
            BackgroundTransparency = 0.1
        })
        boostSweepTween:Play()
        boostSweepTween.Completed:Connect(function()
            local fade = tween_service:Create(boostSweep, TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {
                BackgroundTransparency = 1
            })
            fade:Play()
            fade.Completed:Connect(function()
                if boostSweep then boostSweep.Visible = false end
            end)
        end)
    end

    -- Status text (smaller)
    local statusText = Instance.new("TextLabel")
    statusText.Size = UDim2.new(1, -20, 0, 15)
    statusText.Position = UDim2.new(0, 10, 0, 45)
    statusText.BackgroundTransparency = 1
    statusText.Text = "Initializing..."
    statusText.TextColor3 = Color3.fromRGB(160, 160, 160)
    statusText.TextSize = 11
    statusText.Font = Enum.Font.Gotham
    statusText.TextXAlignment = Enum.TextXAlignment.Left
    statusText.Parent = container

    local totalWalls = #(loadData.walls or {})
    local totalFloors = #(loadData.floors or {})
    local totalRoofs = #(loadData.roofs or {})
    local totalBasements = #(loadData.basements or {})
    local totalPools = #(loadData.pools or {})
    local totalFences = #(loadData.fences or {})
    local totalPaths = #(loadData.paths or {})
    local totalCounters = #(loadData.counters or {})
    local totalObjects = #(loadData.objects or {})
    
    -- Count inner objects
    local function countInnerObjects(structure)
        if not structure.Objects then return 0 end
        local count = #structure.Objects
        for _, obj in pairs(structure.Objects) do
            count = count + countInnerObjects(obj)
        end
        return count
    end
    
    local totalInnerObjects = 0
    for _, wall in pairs(loadData.walls or {}) do
        totalInnerObjects = totalInnerObjects + countInnerObjects(wall)
    end
    for _, roof in pairs(loadData.roofs or {}) do
        totalInnerObjects = totalInnerObjects + countInnerObjects(roof)
    end
    for _, fence in pairs(loadData.fences or {}) do
        totalInnerObjects = totalInnerObjects + countInnerObjects(fence)
    end
    for _, path in pairs(loadData.paths or {}) do
        totalInnerObjects = totalInnerObjects + countInnerObjects(path)
    end
    for _, counter in pairs(loadData.counters or {}) do
        totalInnerObjects = totalInnerObjects + countInnerObjects(counter)
    end
    for _, pool in pairs(loadData.pools or {}) do
        totalInnerObjects = totalInnerObjects + countInnerObjects(pool)
    end
    for _, object in pairs(loadData.objects or {}) do
        totalInnerObjects = totalInnerObjects + countInnerObjects(object)
    end

    -- Only calculate totalItems if it wasn't set in resume mode
    if not resume_mode then
        totalItems = totalWalls + totalFloors + totalRoofs + totalBasements + 
                      totalPools + totalFences + totalPaths + totalCounters + 
                      totalObjects + totalInnerObjects
        estimatedStylingTasks = totalItems * 1.5
    end
    print("Resuming build at item:", currentItem + 1, "of", totalItems)
    -- Enhanced time tracking variables
    local buildStartTime = tick()
    local lastUpdateTime = buildStartTime
    local itemsPerSecond = 0
    local smoothedItemsPerSecond = 0.8 -- Initial estimate: 0.8 items per second
    local timeEstimates = {}
    
    -- Pre-calculate estimated total time based on build complexity
    local estimatedItemsPerSecond = 0.8 -- Base rate
    local complexityMultiplier = 1.0
    
    -- Adjust rate based on build complexity
    if totalInnerObjects > totalItems * 0.3 then
        complexityMultiplier = 1.3 -- Slower for complex builds with many inner objects
    elseif totalInnerObjects > totalItems * 0.5 then
        complexityMultiplier = 1.6 -- Much slower for very complex builds
    end
    
    -- Account for styling tasks (estimate 2x the number of placed items for styling)
    local totalEstimatedTasks = totalItems + estimatedStylingTasks
    
    -- Calculate initial time estimate
    local initialTimeEstimate = (totalEstimatedTasks * complexityMultiplier) / estimatedItemsPerSecond
    local remainingTimeEstimate = initialTimeEstimate

    -- Helper function to format time (moved up before it's used)
    local function formatTime(seconds)
        if seconds <= 0 then return "0s" end
        if seconds < 60 then
            return string.format("%.0fs", seconds)
        elseif seconds < 3600 then
            local mins = math.floor(seconds / 60)
            local secs = seconds % 60
            return string.format("%dm %.0fs", mins, secs)
        else
            local hours = math.floor(seconds / 3600)
            local mins = math.floor((seconds % 3600) / 60)
            return string.format("%dh %dm", hours, mins)
        end
    end

    -- Time estimation text
    local timeText = Instance.new("TextLabel")
    timeText.Size = UDim2.new(1, -20, 0, 12)
    timeText.Position = UDim2.new(0, 10, 0, 60)
    timeText.BackgroundTransparency = 1
    timeText.Text = string.format("Estimated: %s (%d items)", formatTime(initialTimeEstimate), totalEstimatedTasks)
    timeText.TextColor3 = Color3.fromRGB(140, 140, 140)
    timeText.TextSize = 9
    timeText.Font = Enum.Font.Gotham
    timeText.TextXAlignment = Enum.TextXAlignment.Left
    timeText.Parent = container

    -- Update progress function with countdown timer
    local lastBoostCurrent = 0
    local lastItemTime = buildStartTime
    
    local function updateProgress(phase, current, itemName)
        current = current or currentItem
        itemName = itemName or ""
        
        currentItem = current
        local currentTime = tick()
        local elapsedTime = currentTime - buildStartTime
        local timeSinceLastItem = currentTime - lastItemTime
        
        -- Update processing rate
        if current > 0 and timeSinceLastItem > 0.1 then
            local currentRate = 1 / timeSinceLastItem
            itemsPerSecond = currentRate
            
            -- Smooth the rate calculation
            if current > 3 then -- Start smoothing after a few items
                smoothedItemsPerSecond = smoothedItemsPerSecond * 0.8 + itemsPerSecond * 0.2
            end
            
            lastItemTime = currentTime
        end
        
        -- Calculate adjusted total based on phase
        local adjustedTotal = totalItems
        local currentPhaseProgress = current
        
        if phase == "Styling" then
            -- During styling, add estimated styling tasks
            adjustedTotal = estimatedStylingTasks -- or #toDo for exact
            currentPhaseProgress = current
        elseif phase == "Retrying" then
            -- During retry, add retry items
            adjustedTotal = totalItems + estimatedStylingTasks + #retry
            currentPhaseProgress = current
        elseif phase == "Complete!" then
            adjustedTotal = totalItems + estimatedStylingTasks + #retry
            currentPhaseProgress = adjustedTotal
        end
        
        local percentage = adjustedTotal > 0 and math.min(currentPhaseProgress / adjustedTotal, 1) or 0
        
        -- Calculate remaining time using adaptive algorithm
        local timeLeft = 0
        local totalEstimatedTime = initialTimeEstimate
        
        if percentage < 1 then
            if current > 5 and smoothedItemsPerSecond > 0 then
                -- Use adaptive rate for better accuracy
                local remainingItems = adjustedTotal - currentPhaseProgress
                timeLeft = remainingItems / smoothedItemsPerSecond
                
                -- Adjust based on current phase
                if phase == "Styling" then
                    timeLeft = timeLeft * 1.2 -- Styling is typically slower
                elseif phase == "Retrying" then
                    timeLeft = timeLeft * 1.5 -- Retries are slower
                end
                
                totalEstimatedTime = elapsedTime + timeLeft
            else
                -- Use percentage-based estimation for early stages
                if percentage > 0 then
                    totalEstimatedTime = elapsedTime / percentage
                    timeLeft = totalEstimatedTime - elapsedTime
                else
                    timeLeft = remainingTimeEstimate
                end
            end
        end
        
        -- Update remaining time estimate
        remainingTimeEstimate = timeLeft
        
        -- Format time display based on phase
        local timeDisplayText = ""
        if phase == "Complete!" then
            timeDisplayText = string.format("Completed in %s", formatTime(elapsedTime))
            timeText.TextColor3 = Color3.fromRGB(100, 255, 100)
        elseif current < 3 then
            timeDisplayText = string.format("Estimated: %s (%d items)", formatTime(initialTimeEstimate), totalEstimatedTasks)
            timeText.TextColor3 = Color3.fromRGB(140, 140, 140)
        elseif timeLeft > 0 then
            local speedInfo = ""
            if smoothedItemsPerSecond > 0 then
                speedInfo = string.format(" (%.1f/s)", smoothedItemsPerSecond)
            end
            
            timeDisplayText = string.format("%s left | Total: %s%s", 
                formatTime(timeLeft), 
                formatTime(totalEstimatedTime),
                speedInfo
            )
            
            -- Color based on accuracy
            if current > 10 then
                timeText.TextColor3 = Color3.fromRGB(120, 200, 255) -- Blue for accurate estimates
            else
                timeText.TextColor3 = Color3.fromRGB(200, 200, 120) -- Yellow for early estimates
            end
        else
            timeDisplayText = string.format("Elapsed: %s", formatTime(elapsedTime))
            timeText.TextColor3 = Color3.fromRGB(180, 180, 180)
        end
        
        timeText.Text = timeDisplayText
        
        -- Smooth progress animation
        tween_service:Create(progressFill, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
            Size = UDim2.new(percentage, 0, 1, 0)
        }):Play()

        -- Boost trail burst when progress increments
        if currentItem > lastBoostCurrent then
            lastBoostCurrent = currentItem
            if boostTrail and boostTrail.Parent then
                -- Trail always attaches to comet; we briefly extend and fade to simulate exhaust burst
                boostTrail.Size = UDim2.new(0, 12, 0.6, 0)
                boostTrail.BackgroundTransparency = 0.35
                local extend = tween_service:Create(boostTrail, TweenInfo.new(0.18, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {
                    Size = UDim2.new(0, 60, 0.6, 0),
                    BackgroundTransparency = 0.2
                })
                extend:Play()
                extend.Completed:Connect(function()
                    local fade = tween_service:Create(boostTrail, TweenInfo.new(0.22, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {
                        Size = UDim2.new(0, 40, 0.6, 0),
                        BackgroundTransparency = 0.5
                    })
                    fade:Play()
                end)
            end
            -- Trigger boost-from-start sweep to current percent
            triggerBoostSweep(percentage)
            if comet and comet.Parent then
                comet.Visible = percentage > 0 and percentage < 1
            end
        end
        
        -- Update texts (avoid emoji for compatibility)
        percentText.Text = string.format("%.0f%%", percentage * 100)
        titleText.Text = string.format("%s (%d/%d)", phase, currentPhaseProgress, adjustedTotal)
        
        if itemName ~= "" then
            statusText.Text = "Placing: " .. itemName
        else
            statusText.Text = phase
        end
        
        -- Dynamic color changes (same as before)
        if percentage < 0.25 then
            progressFill.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
            percentText.TextColor3 = Color3.fromRGB(255, 150, 150)
            gradient.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 100, 100)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 150, 100))
            }
        elseif percentage < 0.75 then
            progressFill.BackgroundColor3 = Color3.fromRGB(255, 200, 0)
            percentText.TextColor3 = Color3.fromRGB(255, 220, 100)
            gradient.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 200, 0)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 150, 0))
            }
        else
            progressFill.BackgroundColor3 = Color3.fromRGB(0, 255, 150)
            percentText.TextColor3 = Color3.fromRGB(120, 255, 120)
            gradient.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 255, 150)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 200, 255))
            }
        end
        
        -- Animate gradient rotation
        tween_service:Create(gradient, TweenInfo.new(0.5, Enum.EasingStyle.Linear), {
            Rotation = gradient.Rotation + 45
        }):Play()
    end

    local doContinue = nil
    local toDisconnect = {}
    local Gamepasslist = {}

    -- Handle API data structure only
    local gamepasses = {}
    local skills = {}
    
    local gamepassesStr = table.concat(gamepasses, ", ")
    local skillsStr = table.concat(skills, ", ")

    if resume_mode and currentItem > 0 then
        updateProgress("Building", currentItem, "Resuming...")
    end

    doContinue = true
    repeat
        task.wait()
    until doContinue ~= nil
    for _, connection in next, toDisconnect do
        connection:Disconnect()
    end
    if doContinue == false then
        progressGui:Destroy()
        return
    end

    local buildIndex = 0
    local buildIndex2 = 0
    local buildIndex3 = 0
    local numberOfItems
    local retryItems

    -- Handle different data structures for total items
    local totalProgress = 0
    if loadData.Information and loadData.Information.TotalItems then
        totalProgress = loadData.Information.TotalItems * 2
    end



    local decode = {
        cframe = function(cframe)
            return CFrame.new(unpack(cframe))
        end,
        position = function(position)
            return Vector3.new(unpack(position))
        end,
    }
    local function loadPosition(position)
        if not targetPlot or not targetPlot:FindFirstChild("Water") then
            error("Target plot or Water not found")
        end
        return targetPlot.Water.CFrame:PointToWorldSpace(decode.position(position))
    end

    local function loadCFrame(cframe)
        if not targetPlot or not targetPlot:FindFirstChild("Water") then
            error("Target plot or Water not found")
        end
        return targetPlot.Water.CFrame:ToWorldSpace(decode.cframe(cframe))
    end
    local function waitUntilUnpaused()
        while autobuild_functions and autobuild_functions._paused do
            task.wait(0.1)
        end
        return true
    end

	local function loadColor(origin)
		local objects = {}

		local function getMaterialByName(name)
			autobuild_services.material_data._ByName = autobuild_services.material_data._ByName or {}

			if autobuild_services.material_data._ByName[name] then
				return autobuild_services.material_data._ByName[name]
			end

			for materialName, data in pairs(autobuild_services.material_data.Materials or {}) do
				autobuild_services.material_data._ByName[materialName] = data
			end

			return autobuild_services.material_data._ByName[name]
		end

		if
			not pcall(function()
				for key, value in pairs(origin) do
					if value and #value ~= 0 then
						objects[key] = {}

						-- Handle colorId
						objects[key][1] = tonumber(value[1]) or 0

						-- Handle material
						if value[2] ~= 0 and value[2] ~= "0" then
							local rawMaterialName = tostring(value[2])
							local materialTable = getMaterialByName(rawMaterialName)

							if materialTable then
								objects[key][2] = materialTable.ID
							else
								objects[key][2] = 0
							end
						else
							objects[key][2] = 0
						end
					else
						objects[key] = {}
					end
				end
			end)
		then
			return
		else
			return objects
		end
	end

	local function loadRotation(cframe)
		local lookVector = cframe.lookVector
		local rotation = -math.atan2(lookVector.Z, lookVector.X) - math.pi * 0.5
		return rotation < 0 and 2 * math.pi + rotation or rotation
	end

	local function isAbleToPlace(itemName)
		local items = getupvalue(autobuild_services.item_service.GetItem, 1)._itemCache

		if items[itemName] and items[itemName].Seasonal and #items[itemName].Seasonal > 0 then
			return false
		end

		local item = autobuild_services.item_service:GetItem(itemName)

		if item and (item.Price or item.BSPrice) then
			if item.Hidden then
				return false
			end
			if item.BSPrice then
				return false
			end

			local foodFolder = ReplicatedStorage:FindFirstChild("items")
				and ReplicatedStorage.items:FindFirstChild("Food")
			if foodFolder then
				for _, v in pairs(foodFolder:GetChildren()) do
					if v.Name == itemName then
						return false
					end
				end
			end

			local vehiclesFolder = ReplicatedStorage:FindFirstChild("items")
				and ReplicatedStorage.items:FindFirstChild("Vehicles")
			if vehiclesFolder then
				for _, v in pairs(vehiclesFolder:GetChildren()) do
					if v.Name == itemName then
						return false
					end
				end
			end

			local structuralFolder = ReplicatedStorage:FindFirstChild("items")
				and ReplicatedStorage.items:FindFirstChild("Structural")
			if structuralFolder then
				for _, v in pairs(structuralFolder:GetChildren()) do
					if v.Name == itemName then
						return false
					end
				end
			end

			if autobuild_services.item_service.CallItemMethod("", "IsLocked", item, client) then
				return false
			end
			if autobuild_services.item_service.CallItemMethod("", "IsSeasonal", item, client) then
				return false
			end

			return true
		end

		return false
	end

	local function registerFloor(floor, id)
		table.insert(floors, {
			floor = floor,
			id = id,
		})
	end

	local function getFloorFromId(id)
		if id == 0 then
			return targetPlot:FindFirstChild("GroundParts") and targetPlot.GroundParts:FindFirstChild("Ground") or nil
		end
		for _, value in next, floors do
			if value.id == id then
				return value.floor
			end
		end

		return targetPlot.GroundParts:FindFirstChild("Ground")
	end

	local makeStructureCount = nil

	local function makeStructure(data, except, init)
		except = except or false
		init = init or tick()

		if not makeStructureCount then
			makeStructureCount = init
		end

		local dataType = data.Type
		if not dataType then
			makeStructureCount = nil
			return false, 0
		end

		local isPlacing = dataType:find("Place") and dataType:gsub("Place", "")
		local isColoring = dataType:find("Color") and true or false

		if dataType:find("Resize") or dataType:find("Color") then
			isPlacing = false
		end

		local finishRepeating = false
		local connection

		if isPlacing and targetPlot:FindFirstChild("House") then
			local pathToStructures
			if dataType == "PlaceObject" and except == "Fence" and targetPlot.House then
				pathToStructures = targetPlot.House:FindFirstChild("Fences") or targetPlot.House:FindFirstChild("Fence")
			elseif dataType == "PlaceObject" and except == "Counter" and targetPlot.House then
				pathToStructures = targetPlot.House:FindFirstChild("Counters")
					or targetPlot.House:FindFirstChild("Counter")
			else
				pathToStructures = targetPlot.House:FindFirstChild(isPlacing .. "s")
					or targetPlot.House:FindFirstChild(isPlacing)
			end

			if not pathToStructures then
				makeStructureCount = nil
				return false, 0
			end

			connection = pathToStructures.ChildAdded:Connect(function(part)
				finishRepeating = part
			end)
		end

		local result, cost = invokeServer(data)

		if result or cost then
			if isColoring and typeof(data.Object) == "Instance" then
				local applied = autobuild_services.color_service:GetAppearanceData(data.Object)
				for index, expected in pairs(data.Data) do
					local appliedColor = applied[index] and applied[index][1]
					local expectedColor = expected[1]
					if appliedColor == 194 and expectedColor ~= 194 then
						if not table.find(retry, data) then
							table.insert(retry, data)
						end
					end
				end
			end

			if isPlacing then
				local waitStart = tick()
				repeat
					task.wait()
				until finishRepeating or (tick() - waitStart) > 15

				if not finishRepeating then
					if connection then
						connection:Disconnect()
					end
					makeStructureCount = nil
					return false, 0
				end
			end

			if connection then
				connection:Disconnect()
			end
			makeStructureCount = nil
			return (typeof(finishRepeating) == "Instance" and finishRepeating or result), cost
		end

		if type(init) == "number" and ((tick() - makeStructureCount) > 5) then
			return false, 0
		end

		if connection then
			connection:Disconnect()
		end
		task.wait(0.15)
		return makeStructure(data, except, tick())
	end

	local function makeStructureImage(data, except, init)
		except = except or false
		init = init or false
		if type(init) == "number" and not makeStructureCount then
			makeStructureCount = init
		end
		local dataType = data.Type
		local isPlacing = dataType:find("Place") and dataType:gsub("Place", "")
		if dataType:find("Resize") or dataType:find("Color") or dataType:find("SetPicture") then
			isPlacing = false
		end
		local finishRepeating = false
		local connection

		if isPlacing then
			local pathToStructures = nil
			if dataType == "PlaceObject" and except == "Fence" then
				pathToStructures = targetPlot.House:FindFirstChild("Fence" .. "s")
					or targetPlot.House:FindFirstChild("Fence")
			elseif dataType == "PlaceObject" and except == "Counter" then
				pathToStructures = targetPlot.House:FindFirstChild("Counter" .. "s")
					or targetPlot.House:FindFirstChild("Counter")
			else
				pathToStructures = targetPlot.House:FindFirstChild(isPlacing .. "s")
					or targetPlot.House:FindFirstChild(isPlacing)
			end

			connection = pathToStructures.ChildAdded:Connect(function(part)
				finishRepeating = part
			end)
			task.spawn(function()
				pathToStructures.ChildAdded:Wait()
				if not finishRepeating then
					repeat
						task.wait()
					until finishRepeating
				end
			end)
		else
			finishRepeating = true
		end

		local result, cost = fireServer(data)

		if result or cost then
			if isPlacing then
				repeat
					task.wait()
				until finishRepeating
			end
			makeStructureCount = nil
			return (type(finishRepeating) ~= "boolean" and finishRepeating or result), cost
		elseif not result and type(init) == "number" and ((init - makeStructureCount) > 5) then
			if connection then
				connection:Disconnect()
			end
			makeStructureCount = nil
			return false, 0
		end

		task.wait(0.15)

		if connection then
			connection:Disconnect()
		end
		return makeStructureImage(data, except, tick())
	end

	local function makeInnerStructure(data, holder, init)
		local dataType = data.Type
		init = init or tick()

		if not makeStructureCount then
			makeStructureCount = init
		end

		-- Add nil check for data.Name to prevent errors
		if not data.Name or data.Name == "" then
			makeStructureCount = nil
			return false, 0
		end

		local finishRepeating = false
		local connection = targetPlot.House.DescendantAdded:Connect(function(part)
			if part.Name == data.Name then
				finishRepeating = part
			end
		end)

		local result, cost = invokeServer(data)

		if result or cost then
			local waitStart = tick()
			repeat
				task.wait()
			until finishRepeating or (tick() - waitStart) > 15

			if not finishRepeating then
				if connection then
					connection:Disconnect()
				end
				makeStructureCount = nil
				return false, 0
			end

			if connection then
				connection:Disconnect()
			end
			makeStructureCount = nil
			return finishRepeating
		end

		if type(init) == "number" and ((tick() - makeStructureCount) > 5) then
			if connection then
				connection:Disconnect()
			end
			makeStructureCount = nil
			return false, 0
		end

		if connection then
			connection:Disconnect()
		end
		task.wait(0.15)
		return makeInnerStructure(data, holder, tick())
	end

    local function modifyStructure(data)
        if data.Type:find("Color") and data.Data and data.Data[1] and #data.Data[1] == 0 then
            return
        end
        table.insert(toDo, data)
    end

        -- Calculate which items to skip for resume mode
    local itemIndex = 0
    local shouldSkip = function()
        if not resume_mode then return false end
        itemIndex = itemIndex + 1
        return itemIndex <= currentItem
    end
    
    local function placeInnerStructures(mainStructure, mainPart)
        if mainStructure.Objects then
            for _, object in next, mainStructure.Objects do
                -- Skip if object name is nil or empty
                if not object.Name or object.Name == "" then
                    continue
                end
                
                if game.ReplicatedStorage.Modules["_Objects"].FenceService:FindFirstChild(object.Name) then
                    continue
                end

                if not isAbleToPlace(object.Name) then
                    continue
                end

                local side = nil
                if object.Side == 1 then
                    side = false
                elseif object.Side == -1 then
                    side = true
                end

                object.Color = loadColor(object.Color)

                local structureData = {
                    Type = "PlaceObject",
                    Name = object.Name,
                    Side = side,
                    TargetModel = mainPart,
                    Pos = loadCFrame(object.CFrame).Position,
                    Rot = loadRotation(loadCFrame(object.CFrame)),
                }

                if object.Height then
                    structureData.TypeData = {
                        Height = object.Height,
                    }
                end

                if object.StartPart and object.EndPart then
                    structureData.StartPos = loadPosition(object.StartPart)
                    structureData.EndPos = loadPosition(object.EndPart)
                end

                local part, cost = makeInnerStructure(structureData, mainPart)
                if not part then
                    -- Don't increment currentItem for failed inner objects
                    currentItem = currentItem + 1
                    updateProgress("Building", currentItem, "Failed: " .. object.Name)
                    continue
                end

                -- Don't increment currentItem for inner objects as they're not part of main count
                currentItem = currentItem + 1
                updateProgress("Building", currentItem, object.Name)
                -- save_build_progress(currentItem, totalItems, stylingCount, estimatedStylingTasks)
                
                if object.TransformData then
                    local offsetToSend = decode.cframe(object.TransformData)

                    modifyStructure({
                        Type = "TransformObject",
                        Object = part,
                        Offset = offsetToSend,
                    })
                end

                if object.ResizeData then
                    local start = tick()
                    local result
                    repeat
                        result = invokeServer({
                            Type = "ResizeObject",
                            Object = part,
                            Data = { decode.position(object.ResizeData) },
                        })
                        task.wait(0.1)
                    until result or (tick() - start) > 3
                end

                if object.Image then
                    modifyStructure({
                        Type = "SetPicture",
                        Object = part,
                        ID = object.Image,
                    })
                end

                modifyStructure({
                    Type = "ColorObject",
                    Object = part,
                    UseMaterials = true,
                    Data = loadColor(object.Color),
                })

                placeInnerStructures(object, part)
            end
        end
    end

    do
        -- Walls
        for _, wall in next, (loadData.walls or {}) do
            if shouldSkip() then continue end
            waitUntilUnpaused()
            -- Don't overwrite currentItem, increment it
            currentItem = currentItem + 1
            updateProgress("Building", currentItem, "Wall")
            save_build_progress(currentItem, totalItems, stylingCount, estimatedStylingTasks)

            local part, cost = makeStructure({
                Type = "PlaceWall",
                To = loadPosition(wall.Position and wall.Position.To or wall.To),
                From = loadPosition(wall.Position and wall.Position.From or wall.From),
            })
            if not part then
                continue
            end

            -- Handle different color structures
            local rightColor, leftColor
            if wall.Color then
                rightColor = wall.Color.Right
                leftColor = wall.Color.Left
            elseif wall.RightColor and wall.LeftColor then
                rightColor = { wall.RightColor.ColorNumber, wall.RightColor.MaterialNumber }
                leftColor = { wall.LeftColor.ColorNumber, wall.LeftColor.MaterialNumber }
            end

            if rightColor then
                modifyStructure({
                    Type = "ColorObject",
                    Object = part,
                    UseMaterials = true,
                    Data = loadColor({ rightColor }),
                    Side = "R",
                })
            end
            
            if leftColor then
                modifyStructure({
                    Type = "ColorObject",
                    Object = part,
                    UseMaterials = true,
                    Data = loadColor({ leftColor }),
                    Side = "L",
                })
            end
            if autobuild_settings.enable_build_delay then
    task.wait(autobuild_settings.build_delay)
end
            placeInnerStructures(wall, part)
        end
        
        -- Floors
        for i, floor in next, (loadData.floors or {}) do
            if shouldSkip() then continue end
            waitUntilUnpaused()
            currentItem = currentItem + 1
            updateProgress("Building", currentItem, "Floor")
            save_build_progress(currentItem, totalItems, stylingCount, estimatedStylingTasks)

            for index, point in next, floor.Points do
                floor.Points[index] = loadPosition(point)
            end

            local part, cost = makeStructure({
                Type = "PlaceFloor",
                Points = floor.Points,
            })
            if not part then
                continue
            end

            modifyStructure({
                Type = "ColorObject",
                Object = part,
                UseMaterials = true,
                Data = loadColor(floor.Color),
            })
            if autobuild_settings.enable_build_delay then
    task.wait(autobuild_settings.build_delay)
end
            registerFloor(part, floor.Id)
        end
        
        -- Roofs
        for i, roof in next, (loadData.roofs or {}) do
            if shouldSkip() then continue end
            waitUntilUnpaused()
            currentItem = currentItem + 1
            updateProgress("Building", currentItem, "Roof")
            save_build_progress(currentItem, totalItems, stylingCount, estimatedStylingTasks)

            for index, point in next, roof.Points do
                roof.Points[index] = loadPosition(point)
            end

            -- Normalize Settings if missing to match API schema (Height/Type)
            local roofSettings = roof.Settings
            if not roofSettings then
                roofSettings = {
                    Type = roof.Type,
                    Height = roof.Height,
                    IsPreview = true,
                }
            end

            local part, cost = makeStructure({
                Type = "PlaceRoof",
                Points = roof.Points,
                Settings = roofSettings,
            })
            if not part then
                continue
            end

            modifyStructure({
                Type = "ColorObject",
                Object = part,
                UseMaterials = true,
                Data = loadColor(roof.Color),
            })
            if autobuild_settings.enable_build_delay then
    task.wait(autobuild_settings.build_delay)
end
            placeInnerStructures(roof, part)
        end
        
        -- Basements
        for i, basement in next, (loadData.basements or {}) do
            if shouldSkip() then continue end
            waitUntilUnpaused()
            currentItem = currentItem + 1
            updateProgress("Building", currentItem, "Basement")
            save_build_progress(currentItem, totalItems, stylingCount, estimatedStylingTasks)

            local originalCFrame = { targetPlot.Ground.CFrame:ToObjectSpace(loadCFrame(basement.Center)):components() }
            originalCFrame[2] = 0.0000001
            local endPosition = CFrame.new(unpack(originalCFrame))

            local part, cost = makeStructure({
                Type = "PlaceBasement",
                Center = endPosition,
                Size = Vector2.new(unpack(basement.Size)),
            })
        end
        
        -- Pools
        for i, pool in next, (loadData.pools or {}) do
            if shouldSkip() then continue end
            waitUntilUnpaused()
            currentItem = currentItem + 1
            updateProgress("Building", currentItem, "Pool")
            save_build_progress(currentItem, totalItems, stylingCount, estimatedStylingTasks)

            local originalTable = { targetPlot.Ground.CFrame:ToObjectSpace(loadCFrame(pool.Center)):components() }
            local endPosition = CFrame.new(unpack(originalTable))

            local part, cost = makeStructure({
                Type = "PlacePool",
                ItemType = pool.Name,
                Center = endPosition,
                Size = Vector2.new(unpack(pool.Size)),
            })
            if not part then
                continue
            end

            modifyStructure({
                Type = "ColorObject",
                Object = part,
                UseMaterials = true,
                Data = loadColor(pool.Color),
            })
            if autobuild_settings.enable_build_delay then
    task.wait(autobuild_settings.build_delay)
end
            placeInnerStructures(pool, part)
        end
        
        -- Fences
        for i, fence in next, (loadData.fences or {}) do
            if shouldSkip() then continue end
            waitUntilUnpaused()
            currentItem = currentItem + 1
            
            -- Skip if fence name is nil or empty
            if not fence.Name or fence.Name == "" then
                updateProgress("Building", currentItem, "Skipped: No Fence Name")
                continue
            end
            
            updateProgress("Building", currentItem, "Fence")
            save_build_progress(currentItem, totalItems, stylingCount, estimatedStylingTasks)

            local part, cost = makeStructure({
                Type = "PlaceObject",
                Name = fence.Name,
                StartPos = loadPosition(fence.From),
                Pos = loadPosition(fence.To),
            }, "Fence")
            if not part then
                continue
            end

            modifyStructure({
                Type = "ColorObject",
                Object = part,
                UseMaterials = true,
                Data = loadColor(fence.Color),
            })
            if autobuild_settings.enable_build_delay then
    task.wait(autobuild_settings.build_delay)
end
            placeInnerStructures(fence, part)
        end
        
        -- Paths
        for i, path in next, (loadData.paths or {}) do
            if shouldSkip() then continue end
            waitUntilUnpaused()
            currentItem = currentItem + 1
            updateProgress("Building", currentItem, "Path")
            save_build_progress(currentItem, totalItems, stylingCount, estimatedStylingTasks)

            local part, cost = makeStructure({
                Type = "PlacePath",
                To = loadPosition(path.To),
                From = loadPosition(path.From),
            })
            if not part then
                continue
            end

            modifyStructure({
                Type = "ColorObject",
                Object = part,
                UseMaterials = true,
                Data = loadColor(path.Color),
            })
            if autobuild_settings.enable_build_delay then
    task.wait(autobuild_settings.build_delay)
end
            placeInnerStructures(path, part)
        end
        
        -- Counters
        for i, counter in next, (loadData.counters or {}) do
            if shouldSkip() then continue end
            waitUntilUnpaused()
            currentItem = currentItem + 1
            updateProgress("Building", currentItem, counter.Name)
            save_build_progress(currentItem, totalItems, stylingCount, estimatedStylingTasks)

            local part, cost = makeStructure({
                Type = "PlaceObject",
                Rot = loadRotation(loadCFrame(counter.CFrame)),
                Pos = loadCFrame(counter.CFrame).Position,
                Name = counter.Name,
                TargetModel = getFloorFromId(counter.Id or counter.id or 0),
            }, "Counter")
            if not part then
                continue
            end

            modifyStructure({
                Type = "ColorObject",
                Object = part,
                UseMaterials = true,
                Data = loadColor(counter.Color),
            })
            if autobuild_settings.enable_build_delay then
    task.wait(autobuild_settings.build_delay)
end
            placeInnerStructures(counter, part)
        end
        
        -- Objects
        for i, object in next, (loadData.objects or {}) do
            if shouldSkip() then continue end
            waitUntilUnpaused()
            currentItem = currentItem + 1
            
            -- Skip if object name is nil or empty
            if not object.Name or object.Name == "" then
                updateProgress("Building", currentItem, "Skipped: No Name")
                continue
            end
            
            updateProgress("Building", currentItem, object.Name)
            save_build_progress(currentItem, totalItems, stylingCount, estimatedStylingTasks)

            if not isAbleToPlace(object.Name) then
                continue
            end

            local structureData = {
                Type = "PlaceObject",
                Rot = loadRotation(loadCFrame(object.CFrame)),
                Pos = loadCFrame(object.CFrame).Position,
                Name = object.Name,
                TargetModel = getFloorFromId(object.Id or object.id or 0),
            }

            if object.Height then
                structureData.TypeData = {
                    Height = object.Height,
                }
            end

            local part, cost = makeStructure(structureData)
            if not part then
                continue
            end

            modifyStructure({
                Type = "ColorObject",
                Object = part,
                UseMaterials = true,
                Data = loadColor(object.Color),
            })

            if object.TransformData or object.Offset then
                local offsetToSend = decode.cframe(object.TransformData or object.Offset)
                modifyStructure({
                    Type = "TransformObject",
                    Object = part,
                    Offset = offsetToSend,
                })
            end

            if object.ResizeData or object.Size then
                local start = tick()
                local result
                repeat
                    result = invokeServer({
                        Type = "ResizeObject",
                        Object = part,
                        Data = { decode.position(object.ResizeData or object.Size) },
                    })
                    task.wait(0.1)
                until result or (tick() - start) > 3
            end
            if autobuild_settings.enable_build_delay then
    task.wait(autobuild_settings.build_delay)
end
            placeInnerStructures(object, part)
        end
    end

    -- Styling phase
    updateProgress("Styling", currentItem + stylingCount)
    
    -- Process styling tasks without affecting progress count
    for i = stylingCount + 1, #toDo do
        local taskData = toDo[i]
        local success = pcall(function()
            if taskData and taskData.Type then
                if taskData.Type == "SetPicture" then
                    if autobuild_settings.enable_build_delay then
    task.wait(autobuild_settings.build_delay)
end
                    makeStructureImage(taskData)
                elseif taskData.Type == "ColorObject" then
                    if autobuild_settings.enable_build_delay then
    task.wait(autobuild_settings.build_delay)
end
                    makeStructure(taskData)
                elseif taskData.Type == "TransformObject" then
                    if autobuild_settings.enable_build_delay then
    task.wait(autobuild_settings.build_delay)
end
                    makeStructure(taskData)
                else
                    if autobuild_settings.enable_build_delay then
    task.wait(autobuild_settings.build_delay)
end
                    makeStructure(taskData)
                end
                stylingCount = stylingCount + 1
                updateProgress("Styling", stylingCount, "Styling task " .. stylingCount .. "/" .. #toDo)
                save_build_progress(currentItem, totalItems, stylingCount, estimatedStylingTasks)
            end
        end)
        
        if not success then
            continue
        end
    end

    -- Handle retry tasks
    local retryCount = 0
    for i, retryData in pairs(retry) do
        local success = pcall(function()
            if retryData and retryData.Type then
                makeStructure(retryData)
                retryCount = retryCount + 1
                -- Fixed: Add retry count to current item + styling counts
                updateProgress("Retrying", currentItem + stylingCount + retryCount)
                
            end
        end)
        
        if not success then
            continue
        end
    end


    -- Completion
    updateProgress("Complete!", currentItem)
    save_build_progress(currentItem, totalItems, stylingCount, estimatedStylingTasks)
    if stopProgressAnim then pcall(stopProgressAnim) end
    titleText.Text = "🎉 Build Complete!"
    statusText.Text = string.format("Successfully loaded %d items (%d styled)", currentItem, stylingCount)

    -- ✅ Final color flash (green glow)
    tween_service:Create(progressFill, TweenInfo.new(0.3, Enum.EasingStyle.Sine), {
        BackgroundColor3 = Color3.fromRGB(0, 255, 127)
    }):Play()

    -- ✅ Quick success pulse effect
    local finalPulse = Instance.new("NumberValue")
    finalPulse.Value = 1

    local finalPulseTween = tween_service:Create(finalPulse, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Value = 1.1
    })

    local finalPulseConn = finalPulse.Changed:Connect(function()
        progressFill.Size = UDim2.new(1, 0, finalPulse.Value, 0)
    end)

    finalPulseTween:Play()

    finalPulseTween.Completed:Connect(function()
        finalPulseConn:Disconnect()
        finalPulse:Destroy()
    end)

    -- ✅ Animate container shrink
    tween_service:Create(container, TweenInfo.new(0.3, Enum.EasingStyle.Back), {
        Size = UDim2.new(0, 420, 0, 70)
    }):Play()

    -- ✅ Optional shimmer effect one last time
    local shimmer = Instance.new("Frame")
    shimmer.Size = UDim2.new(0, 40, 1, 0)
    shimmer.Position = UDim2.new(-0.2, 0, 0, 0)
    shimmer.BackgroundColor3 = Color3.new(1, 1, 1)
    shimmer.BackgroundTransparency = 0.6
    shimmer.BorderSizePixel = 0
    shimmer.ZIndex = progressFill.ZIndex + 1
    shimmer.Parent = progressFill

    local shimmerCorner = Instance.new("UICorner")
    shimmerCorner.CornerRadius = UDim.new(0, 3)
    shimmerCorner.Parent = shimmer

    local shimmerTween = tween_service:Create(shimmer, TweenInfo.new(1.5, Enum.EasingStyle.Linear), {
        Position = UDim2.new(1.2, 0, 0, 0)
    })
    shimmerTween:Play()

    -- Cleanup shimmer
    task.delay(2, function()
        shimmerTween:Cancel()
        shimmer:Destroy()
    end)

    -- Wait then fade out
    task.wait(3)

    -- ✅ Fade all elements (optional)
    for _, uiElement in ipairs(progressGui:GetDescendants()) do
        if uiElement:IsA("TextLabel") or uiElement:IsA("Frame") or uiElement:IsA("ImageLabel") then
            pcall(function()
                tween_service:Create(uiElement, TweenInfo.new(0.5, Enum.EasingStyle.Quad), {
                    BackgroundTransparency = 1,
                    TextTransparency = 1,
                    ImageTransparency = 1
                }):Play()
            end)
        end
    end

    -- Wait and destroy
    task.wait(0.5)
    progressGui:Destroy()

    print("Build loading finished!")

end

-- Pause API for external control (e.g., UI toggle)
autobuild_functions._paused = autobuild_functions._paused == true and true or false
function autobuild_functions.set_paused(value)
    autobuild_functions._paused = value and true or false
end

-- Runtime settings API (can be driven from UI)
autobuild_functions._settings = autobuild_functions._settings or {
    use_vehicles = false,
    use_blockbux = false,
    use_blockbux_amount = 0,
}

function autobuild_functions.set_settings(opts)
    if type(opts) ~= "table" then return end
    for k, v in pairs(opts) do
        autobuild_functions._settings[k] = v
        autobuild_settings[k] = v -- sync to build logic
    end
end

function autobuild_functions.get_settings()
    return table.clone(autobuild_functions._settings)
end

return autobuild_functions
